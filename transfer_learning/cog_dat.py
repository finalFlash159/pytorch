# -*- coding: utf-8 -*-
"""cog_dat.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z3NeYu0fEyewFqfvWX5jghSzw7Il7TO3
"""

# package
from collections import OrderedDict
import numpy as np
import torch
from torch import optim
import torch.nn as nn
import torchvision
from torchvision import transforms, models
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import accuracy_score

# get data dir
from google.colab import drive

drive.mount("/content/drive")

TRAIN_PATH = "/content/drive/MyDrive/DL/Transfer learning/train"
TEST_PATH = "/content/drive/MyDrive/DL/Transfer learning/test"

transform = transforms.Compose([
    transforms.Resize(255),
    transforms.CenterCrop(224),
    transforms.ToTensor(),
])

train_dataset = torchvision.datasets.ImageFolder(TRAIN_PATH, transform=transform)
test_dataset = torchvision.datasets.ImageFolder(TEST_PATH, transform=transform)

# dataloader
train_loader = torch.utils.data.DataLoader(train_dataset, batch_size=32, shuffle=True)
test_loader = torch.utils.data.DataLoader(test_dataset, batch_size=32, shuffle=False)

def imshow(image_torch):
  # flip image channels to RGB
  image_torch = image_torch.numpy().transpose((1, 2, 0))
  plt.figure(figsize=(10, 10))
  plt.imshow(image_torch)

X_train, y_train  = next(iter(train_loader))

# make grid from batch
image_grid = torchvision.utils.make_grid(X_train[:16, :, :, :], scale_each=True, nrow=4)

imshow(image_grid)

# Dowload and instantiate the pre-trained network
model = models.densenet121(pretrained = True)

model

model.classifier # in this dataset, only classify cat, and dog -> 1 out_features

# freeze all layers
for params in model.parameters():
  params.requires_grad = False

# overwrite classifier of the model
model.classifier = nn.Sequential(OrderedDict([
    ('fc1', nn.Linear(1024, 1)),
    ('sigmoid', nn.Sigmoid()),
]))

# model training
optimizer = optim.Adam(model.classifier.parameters())
loss_function = nn.BCELoss()
train_losses = []


# Setup thiết bị
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model = model.to(device)

NUM_EPOCHS = 10
for epoch in range(NUM_EPOCHS):
  train_loss = 0
  test_loss = 0

  for batch, (image, label) in enumerate(train_loader):

    image = image.to(device)
    label = label.to(device)

    # zero gradients
    optimizer.zero_grad()

    # forward pass
    output = model(image)

    # calc losses
    loss = loss_function(output.squeeze(), label.float())

    # back propa
    loss.backward()

    # update weights
    optimizer.step()

    # update current train loss
    train_loss += loss.item()

  train_losses.append(train_loss)
  print(f"Epoch: {epoch}, Train Loss: {train_loss}")

# losses over epoch
sns.lineplot(x = range(NUM_EPOCHS), y = train_losses)

fig = plt.figure(figsize=(10, 10))
class_labels = {0: 'cat', 1: 'dog'}
X_test, y_test = next(iter(test_loader))

with torch.no_grad():
  X_test = X_test.to(device)
  y_pred = model(X_test)
  y_pred = y_pred.round()
  y_pred = [p.item() for p in y_pred]


# create subplots
for num, sample in enumerate(X_test):
  plt.subplot(4, 6, num+1)
  plt.title(class_labels[y_pred[num]])
  plt.axis('off')
  sample = sample.cpu().numpy()
  plt.imshow(np.transpose(sample, (1, 2, 0)))

# calc accuracy
acc  = accuracy_score(y_test, y_pred)
print(f"Accuracy: {acc}")